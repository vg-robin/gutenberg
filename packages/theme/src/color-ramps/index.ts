/**
 * External dependencies
 */
import Color from 'colorjs.io';

/**
 * Internal dependencies
 */
import { buildRamp } from './lib/index';
import { clampAccentScaleReferenceLightness } from './lib/utils';
import { BG_RAMP_CONFIG, ACCENT_RAMP_CONFIG } from './lib/ramp-configs';
import type {
	RampResult as InternalRampResult,
	RampDirection,
	Ramp,
} from './lib/types';
import { getCachedContrast } from './lib/cache-utils';
import { CONTRAST_COMBINATIONS } from './lib/constants';
export { DEFAULT_SEED_COLORS } from './lib/constants';

/**
 * Creates a background ramp.
 * @param params
 * @param params.seed
 * @param params.debug
 */
export function buildBgRamp( {
	seed,
	debug,
}: {
	seed: string;
	debug?: boolean;
} ): InternalRampResult {
	if ( typeof seed !== 'string' || seed.trim() === '' ) {
		throw new Error( 'Seed color must be a non-empty string' );
	}

	return buildRamp( seed, BG_RAMP_CONFIG, { debug } );
}

const STEP_TO_PIN = 'surface2';
function getBgRampInfo( ramp: InternalRampResult ): {
	mainDirection: RampDirection;
	pinLightness: {
		stepName: keyof Ramp;
		value: number;
	};
} {
	return {
		mainDirection: ramp.direction,
		pinLightness: {
			stepName: STEP_TO_PIN,
			value: clampAccentScaleReferenceLightness(
				new Color( ramp.ramp[ STEP_TO_PIN ].color ).oklch.l,
				ramp.direction
			),
		},
	};
}

/**
 * Creates an accent ramp (ie used by primary, success, info, warning and error
 * ramps).
 * @param params
 * @param params.seed
 * @param params.bgRamp
 * @param params.debug
 */
export function buildAccentRamp( {
	seed,
	bgRamp,
	debug,
}: {
	seed: string;
	bgRamp?: InternalRampResult;
	debug?: boolean;
} ): InternalRampResult {
	if ( typeof seed !== 'string' || seed.trim() === '' ) {
		throw new Error( 'Seed color must be a non-empty string' );
	}

	const bgRampInfo = bgRamp ? getBgRampInfo( bgRamp ) : undefined;
	return buildRamp( seed, ACCENT_RAMP_CONFIG, {
		...bgRampInfo,
		debug,
	} );
}

/**
 * Checks that all bg/fg combinations generated by the ramps meet contrast
 * targets.
 * @param params
 * @param params.bgRamp
 * @param params.accentRamps
 */
export function checkAccessibleCombinations( {
	bgRamp,
	accentRamps = [],
}: {
	bgRamp: InternalRampResult;
	accentRamps?: InternalRampResult[];
} ) {
	const unmetTargets: {
		bgName: keyof Ramp;
		bgColor: string;
		fgName: keyof Ramp;
		fgColor: string;
		unmetContrast: number;
	}[] = [];

	// Assess combinations within each ramp
	[ bgRamp, ...accentRamps ].forEach( ( ramp ) => {
		CONTRAST_COMBINATIONS.forEach( ( { bgs, fgs, target } ) => {
			for ( const bg of bgs ) {
				for ( const fg of fgs ) {
					const bgColor = new Color( ramp.ramp[ bg ].color );
					const fgColor = new Color( ramp.ramp[ fg ].color );
					if ( getCachedContrast( bgColor, fgColor ) < target ) {
						unmetTargets.push( {
							bgName: bg,
							bgColor: bgColor.toString(),
							fgName: fg,
							fgColor: fgColor.toString(),
							unmetContrast: target,
						} );
					}
				}
			}
		} );
	} );
	// Assess each accent ramp's fg color against bg ramp
	accentRamps.forEach( ( ramp ) => {
		CONTRAST_COMBINATIONS.forEach( ( { bgs, fgs, target } ) => {
			for ( const bg of bgs ) {
				for ( const fg of fgs ) {
					const bgColor = new Color( bgRamp.ramp[ bg ].color );
					const fgColor = new Color( ramp.ramp[ fg ].color );
					if ( getCachedContrast( bgColor, fgColor ) < target ) {
						unmetTargets.push( {
							bgName: bg,
							bgColor: bgColor.toString(),
							fgName: fg,
							fgColor: fgColor.toString(),
							unmetContrast: target,
						} );
					}
				}
			}
		} );
	} );

	return unmetTargets;
}

export type RampResult = InternalRampResult;
